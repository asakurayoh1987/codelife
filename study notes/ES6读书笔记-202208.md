[ES6入门](https://es6.ruanyifeng.com/#docs/intro)

[ES各年通过的草案 - 2016年开始](https://github.com/tc39/proposals/blob/main/finished-proposals.md)



[toc]



# ES6（ES2015）

## `let`  和 `const`  命令

作用域的概念   ES5只有全局作用域 和 函数作用域，没有块级作用域的概念

`const` 和 `Object.freeze` ： const 声明的对象和数组，变量实际存储的只是引用，对象的属性与数组元素仍然可以改动，如果想声明一个不可变的变量，可以使用freeze，如下

```javascript
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```



## 变量的解构赋值

数组、对象、字符串、数值、布尔值

解构赋值用于交换变量：

```javascript
let x = 1;
let y = 2;

[x, y]=[y, x];
```



## 字符串的新增方法

 **String 类的静态方法** `String.fromCodePoint()` `String.raw()` 

 **实例方法**  `codePointAt()` `normalize()`  `startsWith()`  `endsWith()` `includes()`  `repeat()` `matchAll()` `at()`



 `String.raw` 转义处理模板字符串

```javascript
// String.raw  转义处理
console.log(String.raw`Hi\\n`);
```



实例方法  `startsWith()`  `endsWith()` `includes()`

```javascript
let s = 'Hello world!';

s.startsWith('Hello'); // true
s.endsWith('!'); // true
s.includes('o'); // true
```

实例方法 `repeat()`

```javascript
// repeat方法返回一个新字符串，表示将原字符串重复n次。
console.log('hello'.repeat(2));
```



## 正则的扩展

### y 修饰符

y 修饰符与g 修饰符都是全局匹配，区别在于 g 的下一次匹配只需要从剩余的字符串中能匹配到即可，而 y 修饰符则需要严格的从上一次匹配结束位置的剩余字符串头部开始匹配。（y相当于每一次匹配需要匹配  开始标志^）

> `y`修饰符的设计本意，就是让头部匹配的标志`^`在全局匹配中都有效。



```javascript
var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"]，剩余字符串是 _aa_a
r2.exec(s) // ["aaa"]，剩余字符串是 _aa_a

r1.exec(s) // ["aa"]，g 修饰符从_aa_a 中匹配到aa
r2.exec(s) // null， y 修饰符从 _aa_a 中未匹配到字符
```

### 新增属性 - RegExp

 `sticky` 属性，布尔值，表示正则是否设置了 `y` 修饰符

 `flags` 属性，字符串，返回正则表达式的修饰符



## 数值的扩展

`Number.isFinite()`用来检查一个数值是否为有限的（finite），即不是`Infinity`。

`Number.isNaN()`用来检查一个值是否为`NaN`。

逐步减少全局性方法： `Number.parseInt()`  `Number.parseFloat()` 

 `Number.isInteger()` 

 `Number.EPSILON` JS 浮点数的最小精度误差

安全整数常量 `Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER` 

 `Number.isSafeInteger()`用来判断一个整数是否落在这个范围之内

### Math对象的扩展

-  `Math.trunc` 去除小数
-  `Math.sign` 判断正负 or 零
-  Math.cbrt 立方根 
- Math.clz32   Math.imul    Math.fround    Math.hypot    
- 对数方法：Math.expm1    Math.log1p    Math.log10    Math.log2
- 双曲函数方法：Math.sinh cosh tanh asinh acosh atanh

## 数组的扩展

### 扩展运算符 `...` 

 复制数组，合并数组

```javascript
const a2 = [...a1]; // 复制数组
const a4 = [...a1, ...a2]; // 合并数组
```

### Array.from

对象转数组

第二个参数可以用于生成数组时，做些额外处理

```javascript
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);
```

### Array.of

将一组值转换为数组

### Array实例方法

- copyWithin  在当前数组内部，copy元素到某些位置，替换原来的数组元素

  ```javascript
  Array.prototype.copyWithin(target, start = 0, end = this.length)
  ```

- find findIndex

-  `fill`  使用给定值，填充数组

-  `entries()` `keys()` `values()` 使用 `for...of` 循环遍历
-  `flat()` 拉平嵌套数组，默认拉平一层，可以通过参数指定拉平的层数， `flatMap()` 将原数组经过map处理后再拉平

## 函数的扩展

### 函数参数默认值

```javascript
function foo(x, y = 5) {
  console.log(x, y);
}
```

与解构赋值结合使用

```javascript
function foo({x, y = 5}) {
  console.log(x, y);
}
```





模板字符串的限制

遗留问题：

JS 中的常规模式 与 严格模式

作用域的概念

模块化编程



# ES2016

数组的扩展 实例方法 `includes()` 返回布尔值



# ES2017

字符串新增实例方法 `padStart()` `padEnd() ` 用于字符串补全长度

## [padStart padEnd](https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9ApadStart%EF%BC%8CpadEnd) 

常见用途，提示字符串格式

```javascript
'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
```



# ES2018

### 正则 -  s 修饰符

正则中的 `.` 一半表示匹配任意字符，但是有两个例外，一个是四个字节的 UTF-16 字符，这个可以用`u`修饰符解决；另一个是行终止符。

- U+000A 换行符（`\n`）
- U+000D 回车符（`\r`）
- U+2028 行分隔符（line separator）
- U+2029 段分隔符（paragraph separator）

 `s` 修饰符的作用就是匹配任意**单个**字符，示例：

```javascript
const re = /foo.bar/s;
// 另一种写法
// const re = new RegExp('foo.bar', 's');

re.test('foo\nbar') // true
re.dotAll // true
re.flags // 's'
```



### 正则 - 后行断言 (没看懂)

### 正则 - Unicode属性类

### 正则 - v 修饰符

### 正则 - 具名组匹配



# ES2019

字符串新增实例方法 `trimStart()` `trimEnd()`

##  [trimStart trimEnd](https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AtrimStart%EF%BC%8CtrimEnd) 

# ES2020

## 正则的扩展

String-prototype-matchAll

数值的扩展

 `BigInt` 数据类型，数字后面加 `n` 

```javascript
const a = 2172141653n;
const b = 15346349309n;

// BigInt 可以保持精度
a * b // 33334444555566667777n

// 普通整数无法保持精度
Number(a) * Number(b) // 33334444555566670000

42n === 42 // false，BigInt的数值与Number不相等
```

 `BigInt` 函数：将其他类型的值转为 BigInt

```javascript
BigInt(123) // 123n
BigInt('123') // 123n
BigInt(false) // 0n
BigInt(true) // 1n
BigInt(1.5) // 报错！！！ RangeError
BigInt('1.5') // 报错！！！ SyntaxError
```







# ES2021

字符串新增实例方法 `replaceAll()` 

##  [replaceAll](https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AreplaceAll) 

## 数值的扩展

### 数值分隔符

允许使用 下划线 `_` 作为分隔符（分隔符仅仅是便于书写与阅读数字，没有其他影响存储类的作用），比如：

```javascript
let budget = 1_000_000_000_000;
// budget === 10 ** 12; // true
console.log(budget); // 1000000000000
```



# ES2022

数组的扩展

新增实例方法

- `at()` 返回指定位置的元素，支持负索引

## 正则

### d 修饰符：正则匹配索引



数组的扩展

实例新增方法

-   `findLast` `findLastIndex` 从后外往前搜索元素
-  `at()` 
