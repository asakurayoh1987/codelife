# 算法描述

## 泽勒一致性

泽勒一致性是由克里斯汀·泽勒开发的用于计算某天是星期几的算法。这个公式是：

```pascal
ℎ=(𝑞+26(𝑚+1)/10+𝑘+𝑘/4+𝑗/4+5𝑗) 𝑚𝑜𝑑 7
```

其中：

1. ℎ 是一个星期中的某一天（0 为星期六，1 为星期天，2 为星期一……6 为星期五)
1. 𝑞 是某月的第几天
1. 𝑚 是月份（3 为三月，4 为 四月……）。一月和二月分别记为上一年的 13 和 14 月
1. 𝑗 是世纪数 -1，（即为 𝑦𝑒𝑎𝑟÷100）
1. 𝑘 是该世纪的第几年（即 𝑦𝑒𝑎𝑟%100）


## 二分查找

本质：删除不存在答案的区间

```c
int arr[1005];
int ans, l = 0, r = n - 1; // 假设 n < 1000
// 正常情况，数组为： 1 3 12 17 29 50 ...
while (l <= r) {
	int mid = (l + r) / 2 // 如果查找的区间很大时，`l + r`可能溢出，这里可以写成`(l & r) + (l ^ r) / 2`
	if (arr[mid) == x) {
		// 查找命中，退出循环
		ans = x;
		break;
	}
	// 调整左值，mid及以左的部分不包含答案，所以l赋值为`mid + 1`
	if (arr[mid] < x) l = mid + 1;
	// 反之调整右值，mid及以右的部分不包含答案，r赋值为`mid - 1`
	else r = mid - 1;
}

// 特殊场景1：数组为： 0 0 0 0 0 1 1 1 1，并且查找第一个值为1的元素，此时在调整左右值时需要注意
while (l != r) { // 注意这里的条件
	int mid = (l + r) / 2;
	// 此时mid及以左的部分不包含答案，所以l可赋值为`mid + 1`
	if (arr[mid] != 1) l = mid + 1;
	// 这里要关注，因为此时mid对应的值为1，但有可能是第一个1，也有可能不是第一个1，所以在调整右值时不能去除它
	else r = mid;
}

// 特殊场景2：数组为：1 1 1 1 0 0 0 0，这里其实与上述场景类似，找最后一个1
while (l != r) {
	// 这里要注意，这里`+ 1`为了避免条件`(l != r)`进入死循环，可以假设场景：l与r相邻，l指向1，r指向0，如果不使用`(l + r + 1)/2`来计算mid，则会进入死循环
	int mid = (l + r + 1) / 2;
	if (arr[mid] != 1) r = mid - 1;
	// 这里要关注，因为此时mid对应的值为1，但有可能是最后一个1，也有可能不是，所以在调整右值时不能去除它
	else l = mid;
}

// 特殊场景3：数组里的值为小数
while (r - l > 0.000001) { // 条件变成精度
	double mid = (l + r) / 2; // 不用再+1，因为对于小数，1太大了
	if (s >= mid) l = mid;	// 左值与右值调整时，可以直接指向mid，删除一半区间
	else r = mid;
}
```

### 舍入取整

比如对于1.2356，我们想保留两位小数舍入取整，得到1.23

对于`printf("%.2f", 1.2356)`得到的是四舍五入后的结果，也就是1.24，如果想舍入取整，有以下两种方式：

- `printf("%.2f\n", (int)(ans * 100) / 100.0);`
- `printf("%.2f\n", ans - 0.005);`

## 判断链表是否存在环

解题关键思路：快慢指针

## 二分答案

