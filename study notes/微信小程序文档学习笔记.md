

# 微信小程序学习笔记

## 一、小程序简介

### 1.1 技术发展

```js
// 早期以JS API的形式提供给企业内部业务使用
WeixinJSBridge.invoke('imagePreview', {
    current: 'http://inews.gtimg.com/newsapp_bt/0/1693121381/641',
    urls: [ // 所有图片的URL列表，数组格式
        'https://img1.gtimg.com/10/1048/104857/10485731_980x1200_0.jpg',
        'https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg',
        'https://img1.gtimg.com/10/1048/104857/10485729_980x1200_0.jpg'
    ]
}, function(res) {
    console.log(res.err_msg)
})

// 公开的JS-SDK
wx.previewImage({
  current: 'https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg',
  urls: [ // 所有图片的URL列表，数组格式
    'https://img1.gtimg.com/10/1048/104857/10485731_980x1200_0.jpg',
    'https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg',
    'https://img1.gtimg.com/10/1048/104857/10485729_980x1200_0.jpg'
  ],
  success: function(res) {
    console.log(res)
  }
})
```

经历过上述两种方案，考虑到移动设备性能及网络加载速度带来的问题（比如白屏）提出了”微信Web资源离线存储“的功能，每个公众号下所有 Web App 累计最多可缓存 5M 的资源，Web资源从微信本地加载，但最终没有对外开放

### 1.2 小程序与普通网页开发的区别

网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中

**因此小程序的逻辑层与渲染层是分开的，逻辑层运行在JSCore中，并没有一个完整的浏览器对象，不能像在浏览器端那样操作DOM**

**同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的**

## 二、小程序的宿主环境

> 小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层

> 渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本

![小程序渲染层与逻辑层](../media/小程序渲染层与逻辑层.png)

> 微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。

1. 小程序启动之后，app.js中定义的App实例的onLaunch回调被执行
2. 找到app.json中pages节的第一个页面作为小程序的首页，微信客户端将首页的代码装载进来
   1. 根据具体页面文件夹下的json文件配置生成一个界面
   2. 装载这个页面的 wxml 结构和wxss 样式
   3. 最后装载js文件，从而构造一个页面
   4. 生成页面时，小程序框架会把数据与wxml一起渲染出最终的结果
3. 在渲染完界面之后，页面实例就会收到一个 onLoad的回调

## 三、小程序配置相关

1. app.json中的networkTimout配置
2. sitemap配置

## 四、小程序框架

### 4.1 生命周期

![小程序生命周期](../media/小程序生命周期.png)

### 4.2 注册页面

**基础库2.9.2开始支持页面中添加behaviors**

[版本分布Ï](https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html)

### 4.3 页面路由

[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html)

这里要注意不同场景，不同路由方式下，各页面的生命周期钩子的触发顺序

### 4.4 WXML

```html
// 模板的定义与使用
<template name="staffName">
  <view>
    FirstName: {{firstName}}, LastName: {{lastName}}
  </view>
</template>

<template is="staffName" data="{{...staffA}}"></template>
<template is="staffName" data="{{...staffB}}"></template>
<template is="staffName" data="{{...staffC}}"></template>
```

### 4.5 WXSS

1. 尺寸单位：rpx
2. 样式导入：@import("wxss相对路径")

### 4.6 WXS

1. WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
2. WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。
3. WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。
4. WXS 函数不能作为组件的事件回调。
5. 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。

#### 4.6.1 使用WXS响应事件（重点，很多前端的UI效果会用到）

> 从基础库版本`2.4.4`开始，支持使用WXS函数绑定事件，WXS函数接受2个参数，第一个是event，在原有的event的基础上加了`event.instance`对象，第二个参数是`ownerInstance`，和`event.instance`一样是一个`ComponentDescriptor`对象

[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)

为了提高页面端事件响应的性能，使用wxs来让代码运行在视图层

[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html)

### 4.7 事件详解

1. 冒泡事件与非冒泡事件（捕获阶段位于冒泡阶段之前）
2. 基础库2.8.1之后bindtap可以写成bind:tap
3. catch来绑定事件会阻止事件向上冒泡
4. mut-bind互斥的事件绑定方式
5. 捕获阶段的事件绑定：capture-bind、capture-catch（捕获的同时取消事件向下传递）
6. dataset的写法
   1. `data-element-type` ，最终会呈现为 `event.currentTarget.dataset.elementType` ；
   2. `data-elementType` ，最终会呈现为 `event.currentTarget.dataset.elementtype` 。
7. mark的使用，与dataset类似，会将事件经过的节点的数据进行合并

[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)

### 4.8 动画

[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html)

### 4.9 关于基础库

[基础库列表](https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html)

如何配置小程序的基础库及查看查比：小程序管理后台->设置->基础设置->功能设置->基础库最低版本设置

### 4.10 运行机制

1. 冷启动与热启动（restartStrategy配置以及退出状态的管理）
2. 进入后台5秒之后进入挂起状态，挂起30分钟或占用系统资源过高会被销毁，可以通过wx.onMemoryWarning事件中进行内存清理操作
3. 更新机制，开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内覆盖绝大多数用户

## 五、自定义组件

### 5.1 定义与使用

注意，是否在页面文件中使用 `usingComponents` 会使得页面的 `this` 对象的原型稍有差异，包括：

- 使用 `usingComponents` 页面的原型与不使用时不一致，即 `Object.getPrototypeOf(this)` 结果不同。
- 使用 `usingComponents` 时会多一些方法，如 `selectComponent` 。
- 出于性能考虑，使用 `usingComponents` 时， `setData` 内容不会被直接深复制，即 `this.setData({ field: obj })` 后 `this.data.field === obj` 。（深复制会在这个值被组件间传递时发生。）

### 5.2 模板与样式

1. 关于多个slot，需要在组件声明时在选项`options`中指定`multipleSlots`为`true`
2. 多个slot，在定义时指定`name`属性，在使用时通过设置`slot`属性为`name`的值来插入到指定的`slot`位置
3. 关于样式隔离，可通过组件声明时在选项`options`中指定`styleIsolation`来修改（从基础库2.10.1开始也可以在配置文件中设置），包括使用Component构造器构造页面的场景
4. 关于addGlobalClass选项，这个选项等价于设置 `styleIsolation: apply-shared` ，但设置了 `styleIsolation` 选项后这个选项会失效。
5. 外部样式类`externalClasses`
6. 组件中通过在类名前添加`~`可以引用页面中的样式，用`^`来引用父组件的样式
7. 虚拟化组件：有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex 布局等，而是希望自定义组件内部的第一层节点能够响应 flex 布局或者样式由自定义组件本身完全决定，这种情况可以在`options`中设置`virtualHost`为`true`

### 5.3 组件间通信

1. 可在父组件里调用 `this.selectComponent` ，获取子组件的实例对象。

2. 若需要自定义 `selectComponent` 返回的数据，可使用内置 `behavior`: `wx://component-export`

   从基础库版本 [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)开始提供支持。

### 5.4 behavior

注意同名字段的覆盖和组合规则：

- 如果有同名的属性 (properties) 或方法 (methods)：
  1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 `behavior` 中的同名属性或方法；
  2. 若组件本身无这个属性或方法，则在组件的 `behaviors` 字段中定义靠后的 `behavior` 的属性或方法会覆盖靠前的同名属性或方法；
  3. 在 2 的基础上，若存在嵌套引用 `behavior` 的情况，则规则为：`父 behavior` 覆盖 `子 behavior` 中的同名属性或方法。
- 如果有同名的数据字段 (data)：
  - 若同名的数据字段都是对象类型，会进行对象合并；
  - 其余情况会进行数据覆盖，覆盖规则为：组件 > `父 behavior` > `子 behavior` 、 `靠后的 behavior` > `靠前的 behavior`。（优先级高的覆盖优先级低的，最大的为优先级最高）
- 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：
  - 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；
  - 对于同种生命周期函数，遵循如下规则：
    - `behavior` 优先于组件执行；
    - `子 behavior` 优先于 `父 behavior` 执行；
    - `靠前的 behavior` 优先于 `靠后的 behavior` 执行；
  - 如果同一个 `behavior` 被一个组件多次引用，它定义的生命周期函数只会被执行一次。

**内置behaviors**

- wx://component-export

### 5.5 组件间关系

[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/relations.html)

### 5.6 数据监听

1. 类似vue中的computed，但不具有缓存的性质
2. 支持`**`通配符写法
3. 数据监听器和属性的 observer 相比，数据监听器更强大且通常具有更好的性能

### 5.7 纯数据字段

> 纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能。从小程序基础库版本 [2.8.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始支持
>
> 指定“纯数据字段”的方法是在 `Component` 构造器的 `options` 定义段中指定 `pureDataPattern` 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。
>
> 从小程序基础库版本 [2.10.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始，也可以在页面或自定义组件的 json 文件中配置 `pureDataPattern`
>
> [数据监听器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html) 可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面。

### 5.8 抽象节点

> 自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。

### 5.9 自定义组件扩展

> 为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。从小程序基础库版本 [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始支持。
>
> 自定义组件的扩展其实就是提供了修改自定义组件定义段的能力
>
> `Behavior()` 构造器提供了新的定义段 `definitionFilter` ，用于支持自定义组件扩展。 `definitionFilter` 是一个函数，在被调用时会注入两个参数，第一个参数是使用该 behavior 的 component/behavior 的定义对象，第二个参数是该 behavior 所使用的 behavior 的 `definitionFilter` 函数列表。

可以通过这个方法在behavior中实现修改组件的字段，实现计算属性的能力

## 六、插件

## 七、基础能力

## 八、连接硬件能力

## 九、开放能力

### 9.1 获取小程序链接

用于在web端打开小程序，几个场景如下：

1. 已有H5页面，通过访问URL Scheme来打开小程序，适用于从短信、邮件、微信外网页等场景打开小程序，微信内的网页如需打开小程序请使用[微信开放标签-小程序跳转按钮](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html#开放标签说明文档)
2. 没有H5页面，通过访问URL Link来打开小程序，适用于从短信、邮件、网页、微信内等场景打开小程序，在微信内或者安卓手机打开 URL Link 时，默认会先跳转官方 H5 中间页
3. 通过[服务端接口](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/short-link/shortlink.generate.html)可以获取打开小程序任意页面的 Short Link。适用于微信内拉起小程序的业务场景，目前只开放给电商类目小程序，具体包含以下一级类目：电商平台、商家自营、跨境电商。

## 十、实时日志



