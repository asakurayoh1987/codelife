# 浏览器相关基础知识

## 一、多进程浏览器

![img](../media/640)

- 浏览器主进程

  相当于浏览器的大脑，主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

- 渲染进程

  核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。

  > 默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全

- 网络进程

  主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，目前已独立出来，成为一个单独的进程。

- 插件进程

  主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

- GPU 进程

  当页面使用了硬件加速时，会使用它来渲染页面。

  > 其实，Chrome 刚开始发布的时候是没有单独 GPU 进程的，都是放到浏览器主进程中的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。

## 二、用户输入URL后的导航流程

![img](../media/640-20240727103802586)

1. 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 通过 IPC 转发给网络进程。
2. 然后，在网络进程中发起真正的 URL 请求。
3. 接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
4. 浏览器进程接收到网络进程的响应头数据之后，发送“提交文档 (CommitNavigation)”消息到渲染进程。
5. 渲染进程接收到“提交文档”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道。
6. 待网络进程中文档数据传输完成，渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接收和解析页面数据了”。
7. 浏览器进程接收到渲染进程“确认提交”的消息之后，导航流程就结束了。此时，渲染进程就会开始解析页面和加载子资源了，浏览器进程将开始移除之前旧的文档，然后更新浏览器进程中的页面状态。

## 三、渲染流程——渲染流水线

1. 解析HTML并构建DOM树（DOM）

2. 样式计算（Style）

   - 将CSS文本转为stylesheets样式表
   - 标准化样式表中的属性，如`{ font-weight: bold }` --> `{ font-weight: 700 }`
   - 计算DOM树中每个节点的具体样式，结果被保存了ComputedStyle结构内

3. 布局（Layout）

   计算DOM树中可见元素的几何位置信息，包括**创建布局树**和**布局计算**两个阶段

   ![img](../media/640-20240727105243708)

4. 分层（Layer）

   针对页面中的复杂效果，如复杂的3d变换、页面滚动、z轴排序等，渲染引擎将为特定的节点生成专用的图层，并生成一个图层树

   拥有层叠上下文属性的元素会被提升为单独的gnfc；需要裁剪的地方也会被创建为单独的图层

   <img src="../media/640-20240727105155012" alt="img" style="zoom:50%;" />

   > 注意，并非布局树的每个节点都包含一个图层，一个节点可以直接或间接地属于一个层，例如一个节点可以从属于父节点的图层

   ![img](../media/640-20240727105139692)

5. 图层绘制（Paint）

   渲染引擎会对图层树中每个图层进行绘制，将一个图层的绘制拆分成很多小的绘制指令，然后把这些指令按顺序组成一个**待绘制列表**

6. 栅格化（生成位图）

   绘制列表准备好后，主线程将其提交给**合成线程**，实际的绘制操作由渲染引擎中的合成线程来完成

   - 合成线程会根据视口位置和大小，**将图层（layer）划分为块（图块 tile）**
   - 合成线程会按照视口附近的图块来优先生成**位图**，实际生成位图的操作由栅格化（将图块转换为位图）来执行，图块是栅格化的最小单位
   - 渲染进程会维护一个栅格化的线程池，栅格化过程通常都会使用GPU来加速生成，使用GPU生成位图的过程叫做快速栅格化，生成的位图被保存在GPU内存中

   ![img](../media/640-20240727105552447)

7. 合成与显示

   - 所有图块都被栅格化后，合成线程将生成绘制图块命令 DrawQuad 提交给浏览器进程
   - 浏览器进程中 viz 组件接收 DrawQuad 命令，根据此命令，将其页面内容绘制在内存中，最后再显示到屏幕上

## 四、回流与重绘

### 1. 更新元素几何属性——回流

几何属性的修改会触发浏览器重新布局（Layout & Layer），渲染树需要重新生成，解析后来的一系列子阶段

![img](../media/640-20240727110035168)

### 2. 更新元素绘制属性——重绘

绘制属性的修改并没有导致几何位置的变化，所以不会导致布局阶段的执行，会直接进入绘制阶段，然后执行后来的子阶段

![img](../media/640-20240727110144487)

### 3. GPU加速——直接合成

如果更改的属性不需要布局和绘制，渲染引擎会跳过布局和绘制，直接进入非主线程——合成线程执行后续合成操作（比如利用 CSS3 的`transform`、`opacity`、`filter`这些属性就可以实现合成效果）

![img](../media/640-20240727110240714)

## 参考

[图解浏览器的多进程渲染机制](https://mp.weixin.qq.com/s/1c159YucpXu5aUPWmjeCmw)

