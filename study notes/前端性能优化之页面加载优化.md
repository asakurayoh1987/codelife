# 前端性能优化之页面加载

## 一、性能优化的必要性

Web应用日益复杂，尤其是如今各种活动营销类的H5页面，想要在实现各种炫酷效果的同时保证丝滑的用户体验，性能优化工作必不可少。同时良好的用户体验，使用户更愿意访问、使用和推广你的网站，提升访问量，从而提高转化率。这里就不列举随着页面加载时间的缩减成交量上升这种虚的例子，举一个最真实也最有说服力的例子：用（老）户（板）反馈说页面加载太慢~

## 二、性能优化的一般步骤

### 1. 主观感知——发现问题

主观感知一般是发现性能问题的最早阶段，页面加载白屏时间过长、首屏渲染太久、图片加载太慢、页面滚动卡顿、动画不流畅等等，这类问题在用户角度的感知最为直接

### 2. 工具审查——定位问题

既然发现了问题，那接下来的步骤就是定位问题，工具的使用往往让我们事半功倍，而对于工具的选择也要区分本地环境（开发环境）与用户环境（生产环境），对于前者，chrome的开发者工具无疑是前端研发人员的最佳选择，它提供一系列面板来定位问题，如：Network、Performance、Lighthouse、Layers、Rendering（后两个在“More tools”中）。

![image-20211115113129935](https://oss.kuyinyun.com/11W2MYCO/rescloud1/939788049a1440be99e248949666ff9f.png)

对于生产环境，由于用户所使用设备的性能、网络的多样化，性能问题的定位要更复杂些，虽然一些线上工具（如WebPageTest等）也能指定设备网络、平台和地区来进行性能检测，但毕竟是单次检测，往往不足以说明真实情况，这时就需要结合Performance API、Network Information API以及请求头中的相关信息（比如IP、UA）来收集用户端真实的性能数据来进行分析了，这块的内容就不扩展了。

### 3. 性能优化——解决问题

通过上一步骤，我们可以获得一些有用的数据（比如资源请求的阶段耗时、资源文件的大小、javascript的执行耗时以及页面渲染相关的信息等）以及一些优化建议（比如Lighthouse输出报表的优化建议及最佳实践），接下来就是具体问题具体对待了（比如早之前在iphone的老机型上遇到过因为使用 `filter: blur`实现背景模糊效果而导致页面上下切换时卡顿），本文接下来主要是从页面加载性能这方面入手，介绍一些基础知识以及行之成效明显的优化手段

## 三、页面加载性能优化

### 1. 了解页面的加载的阶段耗时

要进行页面加载的性能优化，首先得了解页面加载的过程，如下图（引自：https://www.w3.org/TR/navigation-timing/#processing-model）：

![image-20211116105458220](https://oss.kuyinyun.com/11W2MYCO/rescloud1/198a5b077ac2444e9c0f074510008965.png)

上图中描述了页面加载的各个阶段（其实也对应到Performance API记录的数据，有兴趣的同学自行学习），这里我们先关注DNS（DNS解析）、TCP（建立TCP连接）、Request（发送请求）、Response（处理响应）等阶段。如果觉得这个图不够直观，可以在chrome的Network面板查看页面（及资源）加载情况：

![image-20211116104138739](https://oss.kuyinyun.com/11W2MYCO/rescloud1/892c7d0c49f94366b54303538936c63f.png)

点击首页请求，在Timing子面板查看首页的各阶段耗时：

![image-20211116102812549](https://oss.kuyinyun.com/11W2MYCO/rescloud1/6132d7999c5f43d9b2e7dacb9b34b75b.png)

也可以通过Performance面板查看更具体的性能数据，如下图（这里涉及chrome开发者工具的使用了，需要另起篇章，这里就不再扩展了）：

![image-20211116140034550](https://oss.kuyinyun.com/11W2MYCO/rescloud1/4d87495afe4240c6995d85bcec73f5c5.png)

### 2. 了解页面加载相关的性能指标

这一节我们简单介绍一下衡量页面加载性能的相关指标（其实在上一节的最后一张截图中出现过其中几个），chrome中的Lighthouse正是根据这几个指标来计算性能得分的（见下图），**需要注意这些指标会随着时间的推移而调整权重或废弃（比如早期的FMP）**

![image-20211116151242965](https://oss.kuyinyun.com/11W2MYCO/rescloud1/f1304c34df40424bb8d0c440306c1b51.png)

- FP（First Paint）

	首次绘制，标记浏览器第一次向屏幕传输像素的事件，也就是页面在屏幕上首次发生视觉变化的时间，可以理解为白屏时间，目前已不作为Lighthouse的性能衡量指标

- [FCP（First Contentful Paint）](https://web.dev/fcp/)

	首次内容绘制，标记浏览器渲染来自 DOM 的第一个内容的时间点，该内容可以是文本、图像、SVG 甚至 \<canvas\> 元素

![fcp](https://oss.kuyinyun.com/11W2MYCO/rescloud1/fc3fa733253c44f9b1b3da2ce1033b87.svg)

- [LCP（Largest Contentful Paint）](https://web.dev/lcp/)

	最大内容绘制，页面从开始加载到可视区域内可见的最大文本块或图像元素在屏幕上完成渲染的时间

![lcp](https://oss.kuyinyun.com/11W2MYCO/rescloud1/abf02597f073454f977a0950eeaedc7e.svg)

- [FID（First Input Delay）](https://web.dev/fid/)

	首次输入延迟，从用户第一次与页面交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对交互作出响应，并实际能够开始处理事件处理程序所经过的时间，这一般是由于主线程在执行其它的工作，比如解析执行javascript文件等。

![fid](https://oss.kuyinyun.com/11W2MYCO/rescloud1/783467349a5c4faf9d9c2c07cf3503f6.svg)

- [TTI（Time to Interactive）](https://web.dev/tti/)

	可交互时间，从页面开始加载到主要子资源完成渲染，并可快速、可靠的响应用户输入所需的时间，关于它的计算，官方文档有详细的说明：

> 1. 先进行FCP测试
>
> 2. 沿时间轴正向搜索时长至少为 5 秒的安静窗口，其中，*安静窗口*的定义为：没有长任务（在主线程上运行超过 50 毫秒的任务）且不超过两个正在处理的网络 GET 请求。
>
> 3. 沿时间轴反向搜索安静窗口之前的最后一个长任务，如果没有找到长任务，则在 FCP 步骤停止执行。
>
> 4. TTI 是安静窗口之前最后一个长任务的结束时间（如果没有找到长任务，则与 FCP 值相同）
>
>    ![tti计算](https://oss.kuyinyun.com/11W2MYCO/rescloud1/8fb9a35fecfa45b4940337961d2041aa.svg)

- [TBT（Total Blocking Time）](https://web.dev/tbt/)

	总阻塞时间，作为TTI的一个配套指标，计算方式为FCP与TTI之间所有长任务超过50毫秒的部分之和（读着可能有些拗口，可以直接访问官方文档，结果图文说明会很好理解）。那为什么说是TTI的配套指标呢，这里需要结合TTI的安静窗口的定义，如果长任务恰好只有51毫秒并且出现的时机又很特定，会导致很长时间都不满足安静窗口的定义，导致TTI很长，但根据TBT的定义，计算的只是超过50毫秒的部分之和，所以算出来的TBT可能很小

- [CLS（Cumulative layout shift）](https://web.dev/cls/)

	累积布局偏移，这个指标代表了页面的视觉稳定性，而所谓的偏移举个例子相信大家就都明白了：页面的顶部有一个banner位置，但页面刚加载时，banner图片还未加载，而原本位于banner下方的列表顶到页面的顶端，而用户准备点击列表时，banner的图片加载回来了，因为占位导致列表下移，从而使用户误点了banner。更多关于CLS的内容参见官网

![cls](https://oss.kuyinyun.com/11W2MYCO/rescloud1/483dd554e7ef47edbb783b2113690961.svg)

- [SI（Speed Index）](https://web.dev/speed-index/)

	速度指数，衡量页面加载期间视觉内容的显示速度，0-3.4s之间为优，关于它的计算参见官网

### 3. 影响页面加载性能的因素及优化手段

在了解页面的加载过程及可用于衡量的性能指标之后，接下来我们就要做的就是进行具体的性能优化操作来使上述指标达到一个理想的值，这里会结合业务上的一些实践案例，并且考虑篇幅，一些常见的优化手段，比如gzip压缩、动静分离、使用cdn、通过构建实现的雪碧图、代码分包、按需求加载这里就略过了

#### 3.1 静态页面缓存

页面加载的第一步就是获取html，如果是纯静态的内容，当然直接丢到cdn就好，但如果需要根据url中的参数进行动态渲染，在生成html时就会有一些耗时，特别是当访问量大时（比如推送）耗时更明显，所以就引入了静态页面缓存，根据缓存位置的不同分为以下几种：

1. 业务组件层

	由业务侧组件自己管理缓存的生成与刷新，这种实现的基本逻辑是在请求时生成对应标识作为key，再去redis（可替换为别的高速存储）中查询是否存在静态页面缓存，如果存在并且未过期则直接返回，否则模拟一次请求获取html的内容并缓存，此方案的缺点也明显：增加了业务层组件的复杂度

2. nginx层

   使用nginx提供的缓存功能，通过一些简单的配置即可实现，关于nginx缓存功能相关的配置，可以参见[这篇](https://www.nginx.com/blog/nginx-caching-guide/)。此方案相对于上一种，实现难度低、性能好、通用，无需业务侧组件改造，配置完成可以通过请求的响应头来验证缓存命中情况

   ![image-20211118092823014](https://oss.kuyinyun.com/11W2MYCO/rescloud1/79f2e68f026a490e81472d3863f05841.png)

3. cdn缓存

   相对于前一种方案，此方案的优化效果会更明显，因为用户可以从就近的cdn结点获取html，但此方案带来的维护成本也会相对高一点，比如缓存的管理（如何选择一个合适的缓存过期时间及主动刷新缓存）、cdn加速域名带来的一些限制（比如后文提到的http2的服务端推送功能的同域名要求）、cdn的可靠性保证（监控、日志及问题定位等）

#### 3.2 网络请求耗时

还记得前面提到页面加载过程中的DNS、TCP、Request、Response阶段吗，首次访问页面时，DNS与TCP阶段不可避免（不考虑浏览器层面的缓存及socket保持），但对于后续资源的请求是否可以优化呢，答案是肯定的，接下来介绍几种优化方案

1. http2+[preconnect](https://caniuse.com/?search=preconnect)

   出于动静分离的原则，网站一般会将静态资源部署在单独的域名上，比如cdn加速域名，对于静态资源的请求也会经历DNS、TCP等阶段，特别是如今绝大多数网站使用https，在TCP阶段会进行SSL的握手，除去针对SSL的优化（比如nginx层面的缓存、使用TLS1.3来减少握手次数等），还可以使用这里提到的preconnect来提前通知浏览器提前建立好连接
   
   ![image-20211117151335216](https://oss.kuyinyun.com/11W2MYCO/rescloud1/1cecc838e31d47e5804158fd979bdd28.png)

   除了link标签的方式，还可以在首页的响应头进行添加：
   
   ![image-20211117201141170](https://oss.kuyinyun.com/11W2MYCO/rescloud1/1d8d2444a7b04420bcf4abcfd254cbd0.png)
   
   为什么这里会提到http2呢，因为http2的多路复用功能，在浏览器对同一域名的并发请求时，如果不使用http2，可能会建立多个请求，而每个请求都有建立TCP的耗时，而仅使用http2时，会在第一个请求中建立TCP连接，其它同域名的请求会等待TCP连接的建立，但如果使用http2+preconnect，由于连接已经提前建立，并发的几个请求共用一个TCP连接，效果还是很明显的：
   
   - 未启用http2
   
   ![image-20211117153443013](https://oss.kuyinyun.com/11W2MYCO/rescloud1/8891df1038634390a41fcf8a3805510a.png)
   
   ![image-20211117153531860](https://oss.kuyinyun.com/11W2MYCO/rescloud1/2babf4dbde9b4b68b13c874380d98c6f.png)

   ![image-20211117153558323](https://oss.kuyinyun.com/11W2MYCO/rescloud1/f2de238ce73a472b86472849f1e4a43d.png)
   
   - 仅启用http2
   
   ![image-20211117153742804](https://oss.kuyinyun.com/11W2MYCO/rescloud1/2e56bb5c64c249388139667dd4c5da6f.png)
   
   ![image-20211117153804302](https://oss.kuyinyun.com/11W2MYCO/rescloud1/3eab05aff1da46d68db400cf50e29b8d.png)

   ![image-20211117153845567](https://oss.kuyinyun.com/11W2MYCO/rescloud1/be0efae313f04cc79dadfbe2fe3c9eab.png)
   
   - http2+preconnect
   
   ![image-20211117153915640](https://oss.kuyinyun.com/11W2MYCO/rescloud1/b81ac3d219d7432f87591396adac50fa.png)
   
   ![image-20211117153933868](https://oss.kuyinyun.com/11W2MYCO/rescloud1/be35631836de4c368090aa71070300a8.png)
   
   ![image-20211117153949916](https://oss.kuyinyun.com/11W2MYCO/rescloud1/3710e149ebaa40cbbed079a07be4d5c6.png)

2. http2服务端推送

   首页内容的展示与交互，离不开css与js等文件的加载，特别是对于CSR的页面，前端框架对应的js文件加载执行之后才会进行页面数据内容的渲染，除了在构建层面减少文件大小和按需要加载外，如果网站开启了http2，则可以尝试一下http2的服务端推送功能
   
   一般情况下，浏览器拿到html后，会进行DOM解析，解析时遇到css\js文件，则再次发请求获取相应的文件，也就是说这个过程上，多了几次对css\js文件请求，而http2的服务端推送功能，则是在返回html给浏览器的同时，会将接下来需要的资源一并推给浏览器，开启推送功能后，在Network面板可以看到相应的标识：
   
   ![image-20211120093223545](https://oss.kuyinyun.com/11W2MYCO/rescloud1/4130cbc9f0c243cd907e7969ca1db14f.png)
   
   关于如何开启服务端推送，只要源站返回相关的响应头，在nginx（有版本要求）上简单配置一下即可，这里就不多说了，留给大家实操吧

#### 3.3 资源大小优化

这里我们主要提一下关于图片的优化，因为在网站的资源传输过程中，图片资源一般占总数据量的60%以上，对于一些营销活动页面则更甚（如下图），所以对于图片资源的优化一般效果最为明显

<img src="https://oss.kuyinyun.com/11W2MYCO/rescloud1/d2726e3dab6345f79c1409670ffc1bb3.png" alt="image-20211120094818217" style="zoom:50%;" />

关于如何优化图片，这里引用一张google开发者文档中的图片，其中列举了一些优化方案，这里我们挑选几个并结合具体的业务实践来进行说明：

![image-20211120095253382](https://oss.kuyinyun.com/11W2MYCO/rescloud1/c00e519a257d42ed8033f4928a6a0b41.png)

##### 3.3.1 利用css效果来减少图片的使用

1. 页面中常见的一些阴影（合理使用，不然也会带来渲染的性能问题）、边框、渐变之类的效果，可以用css来代替图片，而且效果更好，因为它不会因为分辨率或缩放影响视觉效果

2. 对于一些纹理背景图，可以将图片裁剪为最小重复单元，利用css的background-repeat来平铺实现原图效果

   ![image-20211120101103011](https://oss.kuyinyun.com/11W2MYCO/rescloud1/b59f7fe7ee91489bb15c70885613eecf.png)

3. 利用css滤镜在不新增图片的情况下，实现一些效果，比如置灰

   <img src="https://oss.kuyinyun.com/11W2MYCO/rescloud1/42204d1f8d364e6886fc15b6b9246ab3.png" alt="image-20211120101158809" style="zoom:50%;" />

##### 3.3.2 选择合适的图片格式

1. 对于一些由纯色的线条、形状组成的图片，可以考虑用svg来代表，同时配合如svgo这样的工具进行压缩，不仅文件大小会小很多，而且放大后也不会失真模糊，下图的logo，转成svg后文件大小为原图的1/8

   <img src="https://oss.kuyinyun.com/11W2MYCO/rescloud1/01d42eeeb9a14b009ebc63cf79d5480f.svg" alt="logo.min" style="zoom:50%;" />

2. 对于支持webp的[浏览器](https://caniuse.com/?search=webp)，优先使用webp格式的图片，图片大小可缩小1/3~2/3

   这里有一个[示例](https://h5res.kuyin123.com/musician/prehot/index.html)，示例中是通过js脚本来判断当前系统是否支持webp，如果支持则在根结点上添加"s_webp"的class，而原来页面上所有使用png的位置，都有一份如`.s_webp xxx`的样式覆盖，来修改使用的图片地址，而这些样式的生成以及图片格式的转换都是在构建过程中做的，前者是自定义了一个postcss的插件来修改css文件，添加如下内容，后者则是通过google提供的webp转换工具配合shell脚本来自动将所有png图片都生成对应webp图片

   <img src="https://oss.kuyinyun.com/11W2MYCO/rescloud1/1228b59bfdf94abab9e5c93538590ea6.png" alt="image-20211120104021562" style="zoom:50%;" />

   当然也有很多其它的方法，比如使用picture标签：

   ![image-20211120104514845](https://oss.kuyinyun.com/11W2MYCO/rescloud1/bd1c9cc97cb64e00b8df589faa1a8f18.png)

   亦或是直接使用具有格式转换功能的cdn，一般cdn都会提供此功能，在请求时携带参数，来响应不同格式的图片，甚至可以提前配置好策略，根据请求头`accept`来返回当前浏览器支持的最优的图片，当然这些功能都是付费的哈

3. 使用渐进式的jpg图片，这里直接引用google开发者文档中的示例来进行说明，这主要是从用户体验的角度进行的一些优化，上面一张图是一般图片的加载过程，下面一张则是开启渐近式加载后的效果：

   ![image-20211120105528139](https://oss.kuyinyun.com/11W2MYCO/rescloud1/6261e7caa3bb4d25873cb795ce8bd3a5.png)

   ![image-20211120105539591](https://oss.kuyinyun.com/11W2MYCO/rescloud1/d86d61b08ee84ca88f9e98f137551642.png)

   而对用户层面的感知如下：

   ![image-20211120105654104](https://oss.kuyinyun.com/11W2MYCO/rescloud1/86a537b21bea43549c26b183e6028d96.png)

##### 3.3.3 图片懒加载

页面上的图片不要一股脑全都加载，不仅浪费用户的流量，同时也占用带宽，影响其它资源的加载，对于不在可视区内图片可以使用懒加载的方案，按需加载，这里主要介绍两种方案：

1. 原生方案

   [兼容性参考](https://caniuse.com/?search=loading)，img的loading属性可以实现图片的懒加载，它会在图片在靠近视窗的时候加载图片。这里建议标明图片的宽高尺寸，否则可能会引起渲染的重新布局，如果不确定图片的尺寸，那么网络性能的优化与渲染性能的损失孰优孰劣将不可估计，考虑到兼容性的问题，使用前需了解清楚宿主环境

2. IntersectionObserver API

   [兼容性参考](https://caniuse.com/?search=IntersectionObserver)，此方案是通监听img元素，当其进入可视区域时赋值src（一般会将真正的url保存在如`srcbak`这样的属性上，满足条件时将其值赋给src），从而触发图片加载，兼容性较前者要好不少

##### 3.3.4 调整优先级

对于首页核心内容的图片，比如首页的banner等，可以使用preload的方式让浏览器优先加载该资源，这会显著缩减LCP的时间：

![image-20211120225736324](https://oss.kuyinyun.com/11W2MYCO/rescloud1/c0dffd22db434766a673d01ef6ff0f43.png)

##### 3.3.5 字体裁剪

除了图片资源之外，另g 个可以优化的资源就是字体，特别是对于一些营销活动类的页面，曾经见过UI设计稿中包含4种特殊字体orz……对于这种情况，直接加载动辄十几M的完整字体文件显然是不可取的，此时就要考虑对字体文件进行裁剪，只将页面上用到特殊字体的文字从字体包中提取出来，这里推荐我们常用的[字蛛](https://github.com/aui/font-spider)，官方文档有详细的使用说明（如果也有动态内容使用特殊字体怎么办？拉上产品，动之以情，晓之以理，说服UI不要在动态内容上使用特殊字体）

![image-20211120112156971](https://oss.kuyinyun.com/11W2MYCO/rescloud1/c44ceb3c36674f1cbdcc298ff410b1e6.png)

### 4优化关键渲染路径上的资源

还记得我们刚开始写页面时，就被要求将css写在head标签部分，而js要写在body标签的结尾处，其深层原因就与我们这里要提的关键渲染路径有关。

什么叫关键渲染路径？

> 从收到 HTML、CSS 和 JavaScript 字节到对其进行必需的处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤，优化性能其实就是了解这些步骤中发生了什么 - 即**关键渲染路径**。通过优化关键渲染路径，我们可以显著缩短首次渲染页面的时间。

页面的渲染过程是什么样的呢？看下面这张图：

![image-20211120164803157](https://oss.kuyinyun.com/11W2MYCO/rescloud1/01072436d2b94b6a8c52fde39cfeb792.png)

大概解释一下页面渲染的过程：

1. 浏览器首先拿到html，并开始解析生成DOM
2. 如果遇到js文件则会暂停DOM的解析，下载并执行js文件（因为js可能会修改DOM）
3. 如果遇到css，则下对应的css文件，下载完成后生成CSSOM
4. 结合DOM与CSSOM，生成渲染树（Render Tree）
5. 根据渲染树执行元素的布局（Layout）与绘制（Paint），将页面元素渲染到屏幕上

关于DOM、CSSOM、Render Tree的关系可参见下图：

![image-20211120170254022](https://oss.kuyinyun.com/11W2MYCO/rescloud1/b0300753dc98423b904e6cba1577e221.png)

从上述过程我们可以了解到：

1. CSSOM会影响渲染树的生成，而当存在css文件时，css文件必须下载完毕才能生成CSSOM，由于css是一个完整的语义，比如css第一行将某个元素的背景色设为红色，而最后一行又将其设为蓝色，只有获取完整的css文件后才能正确生成CSSOM，它与DOM的区别就像是一个是编译执行，一个是解释执行，所以为了能更快的生成CSSOM，就要将css放在head标签中，从而使它更早的被下载
2. 而对于js文件，由于它可能会修改DOM（也有可能会修改CSSOM），所以浏览器在解析DOM时遇到js文件，则会暂时DOM的解析，下载并执行js文件，而后再继续解析DOM，为了不阻塞DOM的解析，才会将js放在了body的结尾处。当然除了这种方式也可以在js标签上设置async以及defer属性来告之浏览器，下载js时不阻塞DOM的解析，至于async与defer的区别，就留给读者自行查阅资料了

当页面只包括css时与同时包括css与js时有什么区别，参见下图：

![image-20211120171602316](https://oss.kuyinyun.com/11W2MYCO/rescloud1/cad34cc71de0498f9c74a9bd7d9d3861.png)

当不存在js时，CSSOM并不会阻塞DOM的解析，但当js存在时，由于js除了可能修改DOM，也有可能会修改CSSOM，这就会引起CSSOM构建阻塞DOM解析

综上，为了让页面能尽早渲染，减少白屏时间 ，就要优化关键渲染路径上的资源，使它们能更快的被加载，如何优化？本文的之前的内容中都零散的提到过，比如减少网络耗时、减少文件大小来更快的下载资源、调整资源优先级等等，Lighthouse生成的报告中也有这一块的优化建议，而更多关于渲染路径的讲解可以参见[这里](https://developers.google.com/web/fundamentals/performance/critical-rendering-path)
