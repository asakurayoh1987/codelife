# Wireshark网络分析就是这么简单

## 初试锋芒

### 从一道面试题说起

服务器A：

​	IP：192.168.26.129

​	子网掩码：255.255.255.0

​	默认网关：192.168.26.2

服务器B：

​	IP：192.168.26.3

​	子网掩码：255.255.255.224

​	默认网关：192.168.26.2

**A与B能否正常通信？**

- B根据自己的子网掩码，计算出A属于不同的子网，而**跨子网通信需要默认网关转发**

  根据B的子网掩码，以及`ping`命令中指定的A服务器的IP，计算获取A的网关为192.168.26.128，计算过程：

  ```
  11111111.11111111.11111111.11100000 (子网掩码)
  11000000.10101000.00011010.10000001 (A服务器IP地址)
  -------------------------------------
  11000000.10101000.00011010.10000000 (计算得到的A服务器网关的IP地址，即192.168.26.128)
  ```

- 通过ARP广播查询默认网关192.168.26.2的MAC地址

- 网关返回其MAC地址给服务器B

- 服务器B通过ICMP发出ping包，目标IP即为192.168.26.129，目标MAC地址设置为网关的MAC地址，表示希望默认网关把包转发给服务器A（至于网关有没有转发，目前无从得知）

- 接着服务器B会收到服务器A的ARP广播，询问B的MAC地址，因为在A看来，B属于相同的子网，无需默认网络的参与

- B回复A的ARP请求，把MAC地址告诉A（这里说明B在执行ARP回复时并不考虑子网，即使对于B来说，A在其它子网）

- B收到A的ICMP报文，即ping的回复

#### 补充

- 查看ARP缓存

  ```bash
  arp -a
  ```

- 清除ARP缓存

  ```bash
  # 清除所有ARP缓存
  sudo ip -s -s neigh flush all
  # 清除指定IP的ARP缓存
  sudo arp -d <IP_ADDRESS>
  ```




### 小试牛刀：一个简单的应用实例

**一般情况下，多IP的服务器是这样配路由的：假如自身有一个IP和对方在同一子网，就从这个IP直接发包给对方。假如没有一个IP和对方同子网，就走默认网关**

### Excel文件的保存过程

### 你一定会喜欢的技巧

#### 一、抓包

1. 只抓包头

   ```bash
   tcpdump -i eth0 -s 80 -w /tmp/tcpdump.cap
   ```

   

2. 只抓必要的包

   参见官方提供的[过滤表达式](https://wiki.wireshark.org/CaptureFilters)

   ```bash
   # 只抓IP为10.21.200.131的包（源IP或目标IP为该值）
   tcpdump -i eth0 host 10.32.200.131 -w /tmp/tcpdump.cap
   ```

   **设置Capture Filter之前务必三思，以免把有用的包也过滤掉，尤其是容易被忽略的广播包**

#### 二、个性化设置

1. View -> Time Display Format 设置抓包的时间格式，用来和服务器上的时间对比
2. 不同类型的网络包可以自定义颜色
3. 区分协议的详细设计
4. 如果你在其他时区的服务器上抓包，然后下载到自己的电脑上分析，最好把自己电脑的时区设成跟抓包的服务器一样

#### 三、过滤

1. 根据协议名进行过滤
2. 根据IP地址加port号进行过滤：`ip.addr eq <IP> && tcp.port eq <PORT>`
3. 右键单击Wireshark中感兴趣的一条记录，然后选择`Prepare a Filter --> Selected`，会自动生成过滤表达式

#### 四、让Wireshark自动分析

1. `Analyze --> Expert Info Composite`，查看各种统计信息，比如重传的统计、连接的建立和重置统计
2. `Statistics --> Service Response Time`，再选择协议名称，可以得到响应时间的统计表
3. `Statistics --> TCP Stream Graph`，可以生成几类统计图
4. `Statistics --> Summary`，可以看到一些统计信息，比如平均流量等

### Patrick的故事

### Wireshark的前世今生

## 庖丁解牛

### NFS协议的解析

Network File System（NFS）

**ubuntu 22.04LTS下安装NFS**

```bash
sudo apt update
sudo apt install nfs-kernel-server
# 安装完全之后可能要重启，重启后可以通过以下命令查看服务是否启动
systemctl status nfs-kernel-server.service
# 配置NFS共享目录
sudo vim /etc/exports
# 添加以下行来定义共享目录和可访问此目录的IP及权限，如果IP传*，表示共享给所有机器
/path/to/your/directory IP_ADDRESS_OR_NETMASK(options)
/path/to/your/directory 192.168.1.0/24(rw,sync,no_subtree_check)
/path/to/your/directory 192.168.1.0/24(rw,sync,no_subtree_check)
# 编辑之后需要刷新export
sudo exportfs -ra
# 查看服务器上的NFS共享信息
showmount -e [server_ip]
# 如果发现还是没生效，可以考虑重启服务
sudo systemctl restart nfs-kernel-server
# 设置防火墙
sudo ufw allow 2049
```



通过命令`mount <远端IP>:<远端目录> <本地目录>`来将服务器上的目录挂载到本地，过程中通过wireshark抓包，并使用`portmap || mount || nfs`来进行过滤并分析NFS协议

```bash
# 本地的~/temp/fonts目录要求是存在的
# mac上需要使用以下命令，注意这里的resvport选项
sudo mount -t nfs -o resvport,rw 192.168.64.3:/home/ubuntu/fonts ~/temp/fonts

# 移除挂载
sudo umount ~/temp/fonts
```

*挂载之后，要添加相应的权限，才能共同编辑*

- portmap请求没有得到回复，就可以考虑防火墙对111端口的拦截；如果发现mount请求被服务器拒绝了，就应该检查该共享目录的访问控制

- Linux客户端读NFS共享文件时是多个 READ Call 连续发出去的（本例中是连续两个）
- 每个WRITE Call上有“UNSTABLE”和“FILE_SYNC”标志，前者表示async，后者表示sync，如果挂载时指定了sync方式（`mount -o sync`则为同步，默认为async）
- 可以在mount时用wsize参数来指定每次应该写多少

### 从Wireshark看网络分层

- TCP连接建立（三次握手）时，双方都会把自己的MSS（Maximum Segment Size）告诉对方。MSS加上TCP头和IP头的长度，就得到MTU了
- 无论接受方的MTU有多大，发送方都不能发出超过自己MTU的包

### TCP的连接启蒙

DNS解析

```bash
# 默认使用UDP
nslookup
> paddy_cifs.nas.com

# 强制使用TCP
nslookup
> set vc
> paddy_cifs.nas.com

```

在使用TCP时，要先用3个包来建立连接（3次握手），查询结束后，又用了4个包来断开连接（4次挥手）

**TCP提供有序传输，每个数据包上都要标记上一个序号**，当接收方收到乱序的包时，通过这个序号就可以重新排序了，我们不一定要知道Seq号（序号）的起始值是怎么计算的，但**必须理解它的增长方式**，假设数据段1的起始Seq号为1，长度为1448（意味着它包含了1448个字符），那么数据段2的Seq号就为 1+1448=1449。数据段 2 的长度也是 1448，所以数据段 3 的 Seq 号为1449+1448=2897。也就是说，**一个Seq号的大小是根据上一个数据段的Seq号和长度相加而来的**

由于TCP是双向的，在一个连接中双方都可以是发送方，所以各自维护了一个 Seq 号

TCP头的常见标记位：

- SYN：携带这个标志的包表示正在发起连接请求。因为连接是双向的，所以建立连接时，双方都要发一个SYN
- FIN：携带这个标志的包表示正在请求终止连接。因为连接是双向的，所以彻底关闭一个连接时，双方都要发一个FIN
- RST：用于重置一个混乱的连接，或拒绝一个无效的请求

查看当前机器的tcp连接情况：`netstat -atl`

### 快递员的工作策略——TCP窗口

TCP发送窗口为了解决：

1. 接收方的缓存（接收窗口）可能一下子接受不了这么多数据
2. 网络的带宽也不一定足够大，一口气发太多会导致丢包事故

**很多人会把接收窗口误认为发送窗口**

当发送窗口是由接收窗口决定的时候，我们还可以通过“window size:”的值来判断。而当它由网络因素决定的时候，事情就会变得**非常复杂（后面会介绍）**

发送窗口决定了一口气能发多少字节，而MSS决定了这些字节要分多少个包发完

Window Scale 的作用是向对方声明一个 Shift count，我们把它作为2的指数，再乘以TCP头中定义的接收窗口，就得到真正的TCP接收窗口了

> Wireshark是根据Shift count计算出这个结果的，如果抓包时没有抓到三次握手，Wireshark就不知道该如何计算，所以我们有时候会很莫名地看到一些极小的接收窗口值。还有些时候是防火墙识别不了Window Scale，因此对方无法获得Shift count，最终导致严重的性能问题

### 重传的讲究

发送方的发送窗口是受接收方的接收窗口和网络影响的，其中**限制得更严的因素就起决定作用**

能导致网络拥塞的数据量称为拥塞点，发送方当然希望把发送窗口控制在拥塞点以下，这样就能避免拥塞了，但问题是连网络设备都不知道自己的拥塞点

**策略：**

在发送方维护一个虚拟的拥塞窗口，并利用各种算法使它尽可能接近真实的拥塞点。网络对发送窗口的限制，就是通过拥塞窗口实现的

1. 初建连接，RFC建议将拥塞窗口初始大小定为2个、3个或4个MSS，具体视MSS的大小而定
2. 慢启动过程，RFC建议的算法是每收到n个确认，可以把拥塞窗口增加n个MSS
3. 拥塞避免，RFC建议的算法是在每个往返时间增加1个MSS
   - 从慢启动过渡到拥塞避免的临界窗口值很有讲究。**如果之前发生过拥塞，就把该拥塞点作为参考依据。如果从来没有拥塞过就可以取相对较大的值，比如和最大接收窗口相等**
4. 拥塞发生，表现就是发出去的包不像往常一样得到确认，然后假如迟迟收不到，就认为包已经丢失，于是就会**超时重传**，从发出原始包到重传该包的这段时间称为**RTO**，RFC建议把拥塞窗口降到1个MSS，然后再次进入慢启动过程，
5. 快速重传，当接到方到的包的Seq号比期望的大，就会ACK一个期望的Seq号，不发送方收到3个或以上的重复确认时（**之所以定为3个，是因为网络包有时会乱序，乱序的包一样会触发重复的ACK，而乱序的包一般距离不会相关太大**），就意识到相应的包已经丢了，从而立刻重传它，而不是等待RTO
6. 快速恢复，如果在拥塞避免阶段发生了快速重传，既然后续的包都到达了，说明网络并没有严重拥塞，接下来传慢点就可以了，临界窗口值应该设为发生拥塞时还没被确认的数据量的1/2（但不能小于2个MSS）。然后将拥塞窗口设置为临界窗口值加3个MSS，继续保留在拥塞避免阶段

### 延迟确认与Nagle算法

延迟确认作为TCP处理交互式场景的策略之一，其原理：**如果收到一个包之后暂时没什么数据要发给对方，那就延迟一段时间（在Windows上默认为200毫秒）再确认。假如在这段时间里恰好有数据要发送，那确认信息和数据就可以在一个包里发出去了**

Nagle算法原理：**在发出去的数据还没有被确认之前，假如又有小数据生成，那就把小数据收集起来，凑满一个MSS或者等收到确认后再发送**

### 百家争鸣

### 简单的代码——UDP

- UPD协议头的长度还不到TCP头的一半，所以相同大小的包里，UDP包携带的净数据比TCP包多
- UDP没有Seq和Ack的概念
- 分片和组装
- UDP没有重传机制，丢包由应用层处理
- 分片机制存在弱点，通过包里的“More fragments”的flag标记来表示是否有后续分片（1和0，0表示当前是最后一个分片），如果黑客利用这个特点持续发送flag为1的包，就有可能耗尽内存

### 剖析CIFS协议

### 网络江湖

### DNS小科普

1. 用域账号登录操作系统，就是依靠DNS找到Domain Controller来验证身份
2. A（Address）记录指的是**从域名解析到IP地址**，与之相对**PTR记录**，则是从IP地址解析到名称的
3. SRV记录，Windows的域管理员要特别关心SRV记录，因为它指向域里的资源
4. CNAME记录，又称为Alias记录，即别名
5. DNS的递归查询和迭代查询（使用`dig ${域名} +trace`）
6. DNS的循环工作（round-robin）模式，即同一条记录对应多个IP时，在域名查询返回时，这些IP地址的顺利会变化
7. DNS放大攻击

### 一个古老的协议——FTP

- 控制连接与数据连接
- 主动模式与被动模式

### 上网的学问——HTTP

### 无懈可击的Kerberos

Kerberos的认证结果是双向的—当账号A访问资源B时，不但 B要确保A并非冒充，而且A也要查明B不是假货

### TCP/IP的故事

## 举重若轻

### 一小时内给你答复

### 午夜铃声

可能的原因：乱序是由NIC teaming或者LSO导致的

### 深藏功与名

### 棋逢对手

三板斧：

1. Statistics --> Summary
2. Statistics --> Service Response Time --> ONC-RPC --> Program:NFS Version:3 --> Create Stat
3. Analyze --> Expert Info Composite

### 学无止境

[tshark](http://www.wireshark.org/docs/man-pages/tshark.html)

