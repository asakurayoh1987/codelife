# 微信H5支付本地环境搭建

## 一、前提

1. 非独立模块，会对生产环境产生影响，需在本地搭环境，功能测试稳定再送上生产环境
2. 微信H5支付需要绑定特定的域名，即只有该域名才能调起微信支付，因资质问题目前只有一个域名可用
3. 生成微信支付链接需要传递客户端 IP，访问支付链接时，微信方也会校验该 IP 的一致性
4. 需要使用 https 协议

## 二、环境概览

![image-20240621153653768](https://oss.kuyinyun.com/11W2MYCO/rescloud1/d7e33a1a05c5413b98b422294a5aaec1.png)

### 需要解决的问题

1. 域名映射，让页面支持通过 `pring.kuyin123.com` 来访问

2. 接口打通，包括用于验证用户身份的 cookie 的传递，测试环境服务器，支持 `kuyin.iflysec.com`（用于页面访问）、`api.iflysec.com`（用于接口请求），cookie 是接口在响应时设置在`.iflysec.com`域名下，原先页面访问与接口请求位于相同的一级域名，现在一级域名不同

3. IP处理，通过域名映射，解决了`pring.kuyin123.com`访问至开发环境的问题，但此时浏览器拿到的用户侧 IP 为`127.0.0.1`，然后通过公网访问测试环境服务器时，可以拿到用户的公网 IP，此时在 nginx 服务器上，向后（服务端接口）传递的 `X-Forwarded-For`以及 `X-Real-IP`都存在错误（`X-Real-IP`为`127.0.0.1`，而`X-Forwarded-For`中的第一个IP地址也为`127.0.0.1`）

   > ### `X-Forwarded-For` 头
   >
   > `X-Forwarded-For` 头用于记录客户端的原始 IP 地址以及经过的所有代理服务器的 IP 地址。它是一个逗号分隔的列表，其中第一个 IP 是客户端的 IP，后面的 IP 是经过的代理服务器的 IP。
   >
   > - `$remote_addr`：表示直接连接到 Nginx 的客户端 IP 地址。
   > - `$proxy_add_x_forwarded_for`：这个变量的值等同于 `$http_x_forwarded_for,$remote_addr`，即如果 `X-Forwarded-For` 头已经存在，则在其后追加当前客户端 IP（`$remote_addr`），否则仅使用当前客户端 IP。
   >
   > ### `X-Real-IP` 头
   >
   > `X-Real-IP` 头通常用于记录客户端的原始 IP 地址，尤其是在只有一个代理服务器的情况下。它的值通常直接设置为 `$remote_addr`，以确保客户端的真实 IP 地址在后端服务器上可用。

4. 证书信任，页面需使用https协议，我们虽然可以通过[mkcert](https://github.com/FiloSottile/mkcert)这样的工具创建自签名证书，但在Android手机上使用时，需要解决系统不信任自签名证书的问题（Android 7.0之后系统就不信任用户区证书，只有将手机root，并将证书放置到系统区才会被信任）

## 三、各个击破

### 3.1 域名映射

我们想要实现的是当访问`https://pring.kuyin123.com/xxx`时将请求转发到`https://kuyin.iflysec.com/xxx`，让接口以为用户是通过公网访问`https://kuyin.iflysec.com`，从而获取到用户的公网IP

这里需要通过nginx进行转发，并且下一步骤中处理接口设置的cookie时也需要通过nginx进行处理

推荐使用`SwitchHosts`来管理本地域名映射，它支持分组管理及开关配置。添加如下域名映射，将`pring.kuyin123.com`解析到本地nginx（本地nginx的搭建这里就略去了）

```bash
127.0.0.1 pring.kuyin123.com
```

本地nginx的配置如下：

```nginx
server {
    server_name pring.kuyin123.com;
    listen 443 ssl;
    http2 on;

    # 自签名证书
    ssl_certificate /Users/yudiechao/mkcert/_wildcard.diyring.cc+7.pem;
    ssl_certificate_key /Users/yudiechao/mkcert/_wildcard.diyring.cc+7-key.pem;

    # 对接口请求进行转发
    location ~* /kymall-api {
        # proxy_set_header host               "api.iflysec.com";
        # proxy_set_header x-real-ip          $remote_addr;
        # proxy_set_header x-forwarded-for    $proxy_add_x_forwarded_for;
	      # 请求转发
        proxy_pass https://api.iflysec.com;
    		proxy_cookie_domain .iflysec.com .kuyin123.com;
    }

    # 对页面请求进行转发
    location / {
        # proxy_set_header host               "kuyin.iflysec.com";
        # proxy_set_header x-real-ip          $remote_addr;
        # proxy_set_header x-forwarded-for    $proxy_add_x_forwarded_for;
        proxy_pass https://kuyin.iflysec.com;
        proxy_cookie_domain .iflysec.com .kuyin123.com;
    }
}
```

**演示一下各请求头的作用**

### 3.2 接口打通

接口层会根据cookie来校验用户的身份信息，该cookie是登录接口在响应时设置的，因为原页面的域名`kuyin.iflysec.com`，接口的域名为`api.iflysec.com`，所以登录接口在设置cookie时，其domain属性设置的值为`.iflysec.com`，方便页面跨域请求时能携带上cookie（共同一级域名）

现在页面访问与接口访问使用的域名为`pring.kuyin123.com`，通过本地nginx转发至相应的真实域名，但登录接口响应时所设置cookie的domain属性仍为`.iflysec.com`，如果不处理，页面在请求接口时便不会携带上，这个问题的处理方式有几种，基于当前页面现状，我们选择在nginx上进行简单的处理：**修改接口返回cookie的domain属性**

注意上述nginx配置中的`proxy_cookie_domain .iflysec.com .kuyin123.com;`，这句的作用即是将响应头`Set-Cookie`中的domain属性由`.iflysec.com`改为`.kuyin123.com`

接口层日志：

![image-20240622173127617](https://oss.kuyinyun.com/11W2MYCO/rescloud1/31749302d5dc447490231d4de31c6cee.png)

浏览器日志：

![image-20240622173226830](https://oss.kuyinyun.com/11W2MYCO/rescloud1/55f5ff791a81402a8d0ad487772fbaa4.png)

### 3.3 获取用户公网IP

按照上述的nginx配置，当请求转发到测试环境公网的nginx上时，`X-Forwarded-For`的第一个值即为用户的公网IP地址，但接口层之前处理逻辑是优先使用nginx（现网）带来的请求头，再使用`X-Forwarded-For`中的第一个值

```ts
function getUserIp(ctx) {
	return ctx.get('x-real-ip') || ctx.get('x_real_ip') || ctx.ip;
}
```

而测试环境中`X-Real-IP`头未处理过，所以需要我们进行处理，这里就是直接咨询ChatGPT了，设置了一个变量，该变量取的是`X-Forwarded-For`中第一个不为`127.0.0.1`的值，具体代码就不展示了

### 3.4 信任自签名证书

完成上述的配置后，在PC端Chrome中已经可以完成页面访问和接口请求的流程了，但涉及微信支付，只能在手机端操作，根据前文提到的环境概览，手机端可以通过charles代理来完成请求域名映射

![image-20240621153653768](https://oss.kuyinyun.com/11W2MYCO/rescloud1/d7e33a1a05c5413b98b422294a5aaec1.png)

但前面也提到自Android 7.0之后，系统已经不信任自签名证书了，而我们绕过这个限制的方法就是：**创建一个App（之前已专门写过一个测试WebView用的App，在此基础上修改即可），并设置在该App中信任用户证书**

```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system" />
            <certificates src="user" />
        </trust-anchors>
    </base-config>
</network-security-config>
```

然后在`AndroidManifest.xml`中应该该网络安全配置项

```xml
<application android:networkSecurityConfig="@xml/network_security_config" ...>
	...
</application>
```

最终在手机端安装该WebView测试用的App，通过该App来访问我们的页面则可正常拉起并完成微信支付流程

[测试录屏](https://oss.kuyinyun.com/11W2MYCO/rescloud1/f3103464b7e446688f98b12806bf71ca.mp4)

