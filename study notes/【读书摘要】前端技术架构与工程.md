# 前端技术架构与工程

## 第1章 前端工程化

### 1.1 前端的时代意义

应用程序架构:

- 表现层：负责UI和数据的展示、用户行为的交互、用户输入的收集等，对应到Web领域就是浏览器层。表现层的代码是不安全的
- 表现控制层：负责路由分发、用户输入响应等，简单来说就是负责控制用户能够看到的内容，对应到Web领域可以理解为HTTP服务器、MVC架构模式中的View以及与渲染功能相关的Controller
- 业务逻辑层：负责处理和管理所有的业务逻辑，包括但不限于数据验证、权限管理等
- 数据访问层：负责抽象和封装数据库操作，用于业务逻辑层与数据储存层之间的互动
- 数据储存层：负责数据的持久储存和管理

**关注点分离原则**

将各个层级进行分离、解耦，从而搭建高性能、高可用、可扩展、可伸缩的应用程序架构，同时提高开发团队的迭代和维护效率

### 1.2 架构与工程

> 除了项目本身的复杂度以外，业务的类型、场景、平台、用户群体等特征同样是架构的决定性因素
>
> 任何关于架构的设计和实施必然以业务特征为根本出发点，否则毫无意义
>
> 架构的设计往往需要考虑高可用性、可扩展性、可伸缩性、性能以及安全，要保证项目在多变的生产环境下能够高效且稳定地运行，这些因素同样是从工程角度考虑的要点
>
> 在架构之外，工程从更宏观的角度完善开发和维护流程的管控，强调项目迭代的规范性、有序性、可控性和高效性，并根据架构特征提供额外的辅助功能

![image-20230714134654026](../media/image-20230714134654026.png)

**前端工程化 = 前端技术架构 + 前端工程服务体系**

软件工程与架构着眼于软件的整体，是宏观的概念。将讨论的范畴聚焦于前端（即交互逻辑层），传统的软件工程方法论与架构设计理念并不完全适用，其原因主要有两点：前端技术架构的零散性以及模糊的工程边界

### 1.3 零散的前端架构

完整的前端架构包括以下环节：

- 源码组织规范
- 组件化/模块化
- 数据管理
- 性能优化
- 前后端分离

1. 不同业务类型的技术架构往往包含一些与业务紧密相关的特殊性，而这些特殊的业务类型均在一定程度上造成了前端技术架构的零散性
2. 项目的体量同样影响前端技术架构的设计

**越接近用户的环节技术架构越零散**

### 1.4 模糊的前端工程边界

> 端到端测试指的是将所有组件和模块组装成完整的应用程序后进行的技术性测试，测试范畴包括功能、性能、健壮性、稳定性等

### 1.5 前端架构师的职责

- 根据业务特征设计合理的前端技术架构
- 根据架构特征搭建高效的前端工程服务体系

#### 1.5.1 技术架构

**软件架构的两个基本要素：分治和聚合**

- 编程语言的选择：充分了解语言特性的前提下定制适用于业务类型的开发规范和技术栈
- 编码规范、项目源码的组织结构、依赖管理以及第三方技术选型，技术规范的优劣并没有绝对的评判标准，其唯一的原则是一致性
- 组件化，不仅停留在UI层面，还融入了一些面向对象的理念，比如封装性、扩展性、可组合性、可复用性等
- 前后端分离，将前端开发与后端开发解耦，进而实现开发、维护、部署甚至发布的相对独立性，提高开发效率和快速响应问题
- 性能是评估应用程序高可用性最重要的指标之一，主要分为**加载性能和执行性能**
- **前端架构师需要在深刻理解浏览器渲染原理、编程语言特性、HTTP等知识的前提下制定适用于前端并且与Web整体架构相契合的性能优化策略**

#### 1.5.2 工程服务体系

成本控制是工程的核心关注点，前端工程化最基本的原则是在保证产品功能的前提下尽可能地降低迭代所消耗的成本

##### 1. 开发阶段

根据协作模式的不同可以将开发工作分为**个人独立开发、团队内协作开发和跨团队协作开发**。这三种开发类型各自典型的成本消耗分别为：**个人独立开发过程中由重复性体力劳动所消耗的人力成本**；**团队内多人协作开发过程中由历史代码交接、模块集成所消耗的人力和沟通成本**；**以及跨团队协作开发过程中由各团队技术规范差异和开发进度不同步所消耗的时间、人力和沟通成本**

阶段目标：

- 减少重复性体力劳动
- 建立规范的代码版本管理规范
- 辅助跨团队并行开发

##### 2. 构建阶段

- 编程语言：将源码转换为客户端可执行的代码
- 性能优化：如压缩混淆、动态模块按需加载等
- 部署策略：如给静态资源URL加入Hash指纹和开启CDN加速
- 开发效率：如文档生成、动态构建（HMR）
- 审查评估：如规范审查、性能评估等

##### 3. 测试阶段

##### 4. 部署阶段

部署最核心的地方并不是对不同类型资源的处理，而是对流程的控制

##### 5. 持续化

- 合理地使用工具以提高各个环节独立的工作效率
- 搭建自动化流程来提高跨团队协作开发的效率，降低迭代整体所消耗的时间成本
- 持续化的支持：
  - 前端范畴内的持续化
  - 作为Web应用整体持续化体系的一个子集

##### 6. 监控与统计

### 1.6 总结

始终围绕分层架构中的交互逻辑层展开

- 从前端应用的技术架构本身出发：
  - 关注点：模块解耦、数据管理架构模式、性能以及前后端分离
  - 目标：实现架构的高可用性、可扩展性、可伸缩性，提高独立开发和跨团队开发的效率
- 从架构之外的角度出发
  - 关注点：前端应用的开发、构建、测试、部署及持续化工程体系
  - 目标：建立规范、有序、高效的迭代流程，降低产品迭代所消耗的人力和沟通成功

## 第2章 编程语言

长期使用固定的编程语言很容易令开发者形成思维定式，缺乏跨领域思考和解决问题的能力

从架构层面思考编程语言一是为了选择适用于业务的架构模式和技术选型；二是根据语言特征制定技术规范和开发范式可提高个人以及团队的开发和维护效率；三是由于前端编程语言的单一性，“编程语言仅仅是一种工具”这种论调并不适用于前端

前端技术架构设计中于编程语言层面的考量，包括：

1. 服务端渲染和客户端渲染HTML的对比
2. 使用预编译和后编译技术弥补CSS编程的缺陷
3. 为JavaScript加入强类型和数据不可变性的必要性
4.  JavaScript异步编程的方案选择

### 2.1 HTML

#### 2.1.1 SSR

#### 2.1.2 CSR

##### Virutal DOM

##### 预渲染

用户从输入网站地址按下回车键到能够看到浏览器中有内容输出，这段时间被称为首页的白屏时间

除去DNS查找、TCP握手等开发者无法干预的浏览器前期工作以外，白屏时间的计时起点为浏览器接收到第一个HTTP响应字节，计时终点为HTML文档开始解析

预渲染与其说是技术上的革新，不如说是交互设计上的优化

##### SEO

- 构建阶段的预渲染

  预渲染静态内容指的是在构建阶段将SPA中与用户无关的内容提前解析为HTML字符串并添加至index.html，这部分内容通常称为静态内容

- 服务器判断如果是爬虫则重定向到预渲染服务器

  更好的做法是在构建阶段将SPA各页面提前解析并存放于预渲染服务器中，在接收到用户请求之后即可立即返回数据，SPA的路由管理必须使用HTML5 History模式而非Hash模式，并且需要服务器支持

重新思考HTML渲染方案的选型，其实并不是非此即彼、非黑即白，现实工作中往往要根据业务特征混合使用两者

### 2.2 CSS

#### 2.2.1 从编程语言的角度思考CSS

#### 2.2.2 Less与PostCSS

PostCSS的内核并不会对CSS做任何转化，而是将原始的CSS代码转化为抽象语法树（Abstract Syntax Tree，简称AST）并传递给各个插件，插件根据用户的配置对AST进行处理后还原为最终的CSS代码

#### 2.2.3 CSS in JS

### 2.3 Javascript

语言本身的**灵活性**和实现方案的**多样性**，针对此，约束的途径有两种：**技术选型**与**代码规范**

技术栈又可以细分为**底层技术栈**和**实现层技术栈**，底层技术栈的出发点是“要解决什么问题”，实现层技术栈是在此基础上出于学习曲线、生态等因素的综合评定

代码规范可以细分为**代码风格**和**方案选择**，代码风格与逻辑无关，大都可以用ESLint等工具进行检测和校正。方案选择指的是如果一种逻辑可以用多种方案实现如何选择最合理的方案，典型的案例是JavaScript异步编程，是选择常规的回调函数还是Promise，在Promise基础上使用Generator还是async/await

#### 2.3.1 静态类型

#### 2.3.2 不可变性

JavaScript中函数的传参方式只有一种，即值传参，对于经常被误解的传递对象时，在函数内部进行了修改，外部的对象也会生效，是因为传递的其实是对象的内存地址（指南）的一个拷贝，通过下面的例子就可以说明：

```javascript
function fn(obj) {
  obj = {a: 1};
}
let obj = {a: 0};
fn(obj);
console.log(obj); // {a: 0}
```

obj传入fn后，重新赋值了，但函数执行结束后，obj的值未发生变化，说明传递的是外层obj对象的内存地址的拷贝

**JavaScript函数传参的方式更准确的术语叫作Call by sharing**

#### 2.3.3 异步编程

- 调用栈
- 堆
- 任务队列
- 事件循环

**ESP（Extended Stack Pointer，栈指针寄存器）用于储存调用栈的当前位置**；EIP（Extended Instruction Pointer，指令寄存器）用于储存即将执行程序的内存地址

## 第3章 技术规范

### 3.1 技术选型

- 功能
- 性能
- 稳定性
- 生态
- 学习曲线
- 作者
- 社区
- 开源协议

### 3.2 资源管理

- 将项目文件按照**模块**、**功能**或者**类型**分别存放于不同目录下是资源管理的基本模式
- 分治是资源管理的核心思想

#### 3.2.1 目录结构

通用原则：

- 源码文件单独目录存放
- 构建产出文件单独目录存放
- 第三方框架/工具单独目录存放
- 工程配置文件单独目录存放
- 单元测试文件单独目录存放
- 媒体资源（图片/视频/字体等）单独目录存放

#### 3.2.2 命名规范

命名规范的核心是强化文件名称的语义性，其次是格式的统一，目的是力求达到“观其名而知其貌”的效果

> 相对来说，目录结构和命名规范对于体量较小或生命周期很短的项目并没有很强的必要性；而对于架构复杂、模块众多、资源多样的大型项目而言，具有语义性和一致性的目录结构和命名规范能够辅助开发者理解架构模块体系，减少项目交接和多人协作开发过程所消耗的人力和时间成本

### 3.3 编码风格

- 统一：是否及格的底线
- 语义
- 注释
  - 一部分是使用既定的格式对代码的元素进行说明
  - 一部分是在语义化之外，通过自然语言描述以帮助开发者更容易理解源码
- 美观

#### 3.3.1 JavaScript的高性能与易读性

#### 3.3.2 CSS编程范式与面向对象

- OOCSS（Object Oriented CSS——面向对象的CSS）：遵循SOLID原则中的单一职责原则和关注点分离原则

  OOCSS将每个classname视为一个功能单一的CSS组件，业务组件通过组合多个CSS组件实现综合的样式效果，其显著的优点是**可组合性高**，非常适用于可高度扩展的前端项目

- BEM（Block、Element、Modifier）

  是OOCSS方法论的一种实现模式，底层仍然是面向对象的思想

  - Block：代表一个逻辑或功能独立的组件，具有一定的共用性，可以单独作用也可以互相嵌套
  - Element：是Block内部的一个子组件，**仅在Block范畴内使用，不能被外部访问**
  - Modifier：用于描述一个Block或Element的表现或者行为

  BEM规范下的classname的命名格式：*block-name\_\_\<element-name\>--\<modifier-name\>\_\<modifier-value\>*

  - 命名均小写，复合单词用连字符连接
  - Block与Element之间使用双下画线连接
  - Modifier与Block/Element使用双连符连接
  - modifier-name与modifier-value之间使用单下画线连接

## 第4章 组件化

组件化旨在解决的主要现实问题，即**解耦**和**复用**

### 4.1 组件与模块

